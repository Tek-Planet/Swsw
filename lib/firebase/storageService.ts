
import { getDownloadURL, ref, uploadBytes } from 'firebase/storage';
import { storage } from './firebaseConfig';
import { getFunctions, httpsCallable } from 'firebase/functions';

const uploadImageAndGetDownloadURL = async (imageUri: string, userId: string): Promise<string | null> => {
  try {
    console.log(`[uploadImageAndGetDownloadURL] Starting upload for user: ${userId}`);
    
    // 1. Fetch the image data from the local URI
    console.log('[uploadImageAndGetDownloadURL] Fetching image from URI:', imageUri);
    const response = await fetch(imageUri);
    if (!response.ok) {
      throw new Error('Failed to fetch image: ' + response.statusText);
    }
    
    // 2. Convert the image data to a blob
    const blob = await response.blob();
    console.log('[uploadImageAndGetDownloadURL] Image converted to blob.');

    // 3. Create a unique reference in Firebase Storage
    const storageRef = ref(storage, `images/${userId}/${Date.now()}`);
    console.log('[uploadImageAndGetDownloadURL] Created storage reference.', storageRef);

    // 4. Upload the blob to the reference
    console.log('[uploadImageAndGetDownloadURL] Uploading blob to Firebase Storage...');
    const uploadResult = await uploadBytes(storageRef, blob);
    console.log('[uploadImageAndGetDownloadURL] Upload successful.', uploadResult);

    // 5. Get the public download URL
    const downloadURL = await getDownloadURL(storageRef);
    console.log('[uploadImageAndGetDownloadURL] Obtained download URL:', downloadURL);
    
    return downloadURL;
  } catch (error) {
    console.error('some error:', error);
    
    // Returning null signals that the upload failed.
    return null;
  }
};

/**
 * [NEW] Uploads an image to a secure S3 bucket and returns the S3 key.
 * This function uses a pre-signed URL generated by the backend for security.
 */
const uploadImageAndGetS3Key = async (imageUri: string): Promise<string | null> => {
  console.log('[uploadImageAndGetS3Key] Starting S3 upload process.');

  try {
    // 1. Get the Firebase Functions instance
    const functions = getFunctions();
    const generateS3UploadUrl = httpsCallable(functions, 'generateS3UploadUrl');

    // 2. Fetch the image data and determine its type
    console.log('[uploadImageAndGetS3Key] Fetching image from URI:', imageUri);
    const response = await fetch(imageUri);
    if (!response.ok) {
      throw new Error('Failed to fetch image: ' + response.statusText);
    }
    const imageBlob = await response.blob();
    const fileType = imageBlob.type;
    console.log(`[uploadImageAndGetS3Key] Image fetched. Type: ${fileType}`);

    // 3. Call the backend function to get a pre-signed URL
    console.log('[uploadImageAndGetS3Key] Requesting pre-signed URL from backend...');
    const result: any = await generateS3UploadUrl({
      fileName: imageUri.split('/').pop() || 'unknown-file',
      fileType: fileType,
    });

    const { uploadUrl, s3Key } = result.data as { uploadUrl: string; s3Key: string };
    if (!uploadUrl || !s3Key) {
      throw new Error('Backend did not return a valid uploadUrl and s3Key.');
    }
    console.log('[uploadImageAndGetS3Key] Received pre-signed URL and s3Key.');

    // 4. Upload the image blob directly to the S3 URL
    console.log('[uploadImageAndGetS3Key] Uploading image to S3...');
    const uploadResponse = await fetch(uploadUrl, {
      method: 'PUT',
      body: imageBlob,
      headers: {
        'Content-Type': fileType,
      },
    });

    if (!uploadResponse.ok) {
      throw new Error('S3 upload failed: ' + uploadResponse.statusText);
    }
    console.log('[uploadImageAndGetS3Key] S3 upload successful.');

    // 5. Return the S3 key to be saved in Firestore
    return s3Key;

  } catch (error) {
    console.error('Error in S3 upload process:', error);
    // Consider more specific error handling or logging
    return null;
  }
};

export { uploadImageAndGetDownloadURL, uploadImageAndGetS3Key };
